import rclpy

from array import array
from importlib import import_module
from rclpy.node import Node
from lll_msgs.msg import Float64VectorStamped
from std_msgs.msg import Header


# Utils functions


# Get type from string definition
def getMessageType(packageName, topicType):
    # Construct the full module name
    module_name = f"{packageName}.msg"

    # Dynamically import the message module
    message_module = import_module(module_name)

    # Get the message class from the module
    try:
        return getattr(message_module, topicType)
    except AttributeError:
        raise Exception(f"{topicType} is not a message type inside {module_name}.msg")


# Transform a struct string def into a list
# example : "main.sub1.sub2.value" => ["main","sub1","sub2","value"]
def string_to_list(string: str):
    str_list = string.split(".")
    return str_list


# Get class attribute from string, raise an error if the attribute is not part of the class
def get_class_attribute_value(obj, fieldName: str):
    try:
        return getattr(obj, fieldName)
    except AttributeError:
        raise Exception(
            f"This object {obj} does not contain a field for '{fieldName}'. Please try another field name."
        )


# Get class attribute from array, raise an error if an attribute is not part of the class
def get_nested_class_attribute_value(obj, nestedFieldName: str):
    try:
        if len(nestedFieldName) == 0:
            return [float(value) for value in obj]
        else:
            fieldname_list = string_to_list(nestedFieldName)
            val = obj
            for fieldName in fieldname_list:
                val = get_class_attribute_value(val, fieldName)
            return val
    except AttributeError:
        raise Exception(
            "One or more of your strings are not defined in the previous object. Please try other field names."
        )


def get_array_from_field_names(msg, fieldNames: list[str]):
    try:
        val = []
        for fieldName in fieldNames:
            fieldValue = get_nested_class_attribute_value(msg, fieldName)

            if type(fieldValue) is list or type(fieldValue) is array:
                float_list = [float(value) for value in fieldValue]
                val += float_list
            else:
                val.append(float(fieldValue))
        return val
    except ValueError:
        raise Exception("Field values must be convertable to float.")


class LLLVectorizerNode(Node):
    def __init__(self):
        super().__init__("lll_vectorizer_node")

        self.declare_parameters(
            namespace="",
            parameters=[
                ("keep_header", True),
                ("sub_topic", ""),
                ("sub_package", ""),
                ("sub_type", ""),
                ("pub_topic", ""),
                ("field_names", [""]),
            ],
        )

        self.keep_header = self.get_parameter("keep_header").get_parameter_value().bool_value
        self.field_names = (
            self.get_parameter("field_names").get_parameter_value().string_array_value
        )
        self.sub_topic = self.get_parameter("sub_topic").get_parameter_value().string_value
        self.sub_package = self.get_parameter("sub_package").get_parameter_value().string_value
        self.sub_type = self.get_parameter("sub_type").get_parameter_value().string_value
        self.pub_topic = self.get_parameter("pub_topic").get_parameter_value().string_value

        self.subscriber = self.create_subscription(
            getMessageType(self.sub_package, self.sub_type),
            self.sub_topic,
            self.sub_callback,
            10,
        )

        self.publisher = self.create_publisher(Float64VectorStamped, self.pub_topic, 10)

        self.get_logger().info(
            "\nVectorizer Node created\n\nListen to: %s\n\nConvert from type:\n   %s\nTo:\n   lll_msgs/msg/Float64VectorStamped"
            % (
                self.sub_topic,
                self.sub_type,
            )
        )

    def sub_callback(self, msg):
        msg_vectorized = Float64VectorStamped()

        if self.keep_header:
            try:
                msg_vectorized.header = getattr(msg, "header")
            except AttributeError:
                raise Exception(
                    "If keep_header = True, the message type must have an header of type std_msgs/msg/Header"
                )
        else:
            msg_vectorized.header = Header()
            msg_vectorized.header.stamp = self.get_clock().now().to_msg()
            msg_vectorized.header.frame_id = "lll_vectorizer"

        msg_vectorized.data = get_array_from_field_names(msg, self.field_names)

        self.publisher.publish(msg_vectorized)
        self.get_logger().debug(
            "Message translated, %d values converted" % len(msg_vectorized.data)
        )
        self.get_logger().debug("Result: %s" % msg_vectorized.data)


def main(args=None):
    rclpy.init(args=args)
    subscriber_vectorizer = LLLVectorizerNode()
    try:
        rclpy.spin(subscriber_vectorizer)
    except KeyboardInterrupt:
        subscriber_vectorizer.destroy_node()
        print("KeyboardInterupt received")


if __name__ == "__main__":
    main()
